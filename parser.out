Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> block
Rule 1     block -> statement
Rule 2     block -> statement block
Rule 3     statement -> prodstatement ;
Rule 4     statement -> control
Rule 5     prodstatement -> INT ID = numericexp
Rule 6     prodstatement -> FLOAT ID = numericexp
Rule 7     prodstatement -> STRING ID = stringexp
Rule 8     prodstatement -> BOOLEAN ID = booleanexp
Rule 9     expr -> numericexp
Rule 10    expr -> booleanexp
Rule 11    expr -> stringexp
Rule 12    control -> IF ( booleanexp ) { block } elif else
Rule 13    elif -> ELIF ( booleanexp ) { block } elif
Rule 14    elif -> epsilon
Rule 15    else -> ELSE { block }
Rule 16    else -> epsilon
Rule 17    control -> WHILE ( booleanexp ) { block }
Rule 18    control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block }
Rule 19    prodstatement -> ID = expr
Rule 20    prodstatement -> FLOAT ID
Rule 21    prodstatement -> INT ID
Rule 22    prodstatement -> STRING ID
Rule 23    prodstatement -> BOOLEAN ID
Rule 24    numericexp -> ID + numericexp
Rule 25    numericexp -> ID - numericexp
Rule 26    numericexp -> ID / numericexp
Rule 27    numericexp -> ID * numericexp
Rule 28    numericexp -> ID ^ numericexp
Rule 29    numericexp -> num
Rule 30    numericexp -> numericexp operator numericexp
Rule 31    numericexp -> ( numericexp )
Rule 32    num -> INUMBER
Rule 33    num -> FNUMBER
Rule 34    operator -> +
Rule 35    operator -> -
Rule 36    operator -> *
Rule 37    operator -> /
Rule 38    operator -> ^
Rule 39    concat -> ID
Rule 40    concat -> STR
Rule 41    stringexp -> concat
Rule 42    stringexp -> ID + stringexp
Rule 43    stringexp -> ID + ID
Rule 44    stringexp -> stringexp + stringexp
Rule 45    bool -> TRUE
Rule 46    bool -> FALSE
Rule 47    bool -> ID
Rule 48    booleanexp -> booleanexp AND booleanexp
Rule 49    booleanexp -> booleanexp OR booleanexp
Rule 50    booleanexp -> booleanexp EQUAL booleanexp
Rule 51    booleanexp -> booleanexp DIFFERENT booleanexp
Rule 52    booleanexp -> ID EQUAL stringexp
Rule 53    booleanexp -> ID DIFFERENT stringexp
Rule 54    booleanexp -> ID EQUAL numericexp
Rule 55    booleanexp -> ID DIFFERENT numericexp
Rule 56    booleanexp -> ID GREATERTHAN numericexp
Rule 57    booleanexp -> ID LESSTHAN numericexp
Rule 58    booleanexp -> ID < numericexp
Rule 59    booleanexp -> ID > numericexp
Rule 60    boolop -> strcomp
Rule 61    boolop -> numcomp
Rule 62    boolop -> bool
Rule 63    comp -> EQUAL
Rule 64    comp -> DIFFERENT
Rule 65    comp -> GREATERTHAN
Rule 66    comp -> LESSTHAN
Rule 67    comp -> <
Rule 68    comp -> >
Rule 69    strcomp -> stringexp DIFFERENT stringexp
Rule 70    strcomp -> stringexp EQUAL stringexp
Rule 71    numcomp -> numericexp comp numericexp
Rule 72    epsilon -> <empty>
Rule 73    statement -> PRINT ( ID )

Terminals, with rules where they appear

(                    : 12 13 17 18 31 73
)                    : 12 13 17 18 31 73
*                    : 27 36
+                    : 24 34 42 43 44
-                    : 25 35
/                    : 26 37
;                    : 3 18 18
<                    : 58 67
=                    : 5 6 7 8 19
>                    : 59 68
AND                  : 48
BOOLEAN              : 8 23
DIFFERENT            : 51 53 55 64 69
ELIF                 : 13
ELSE                 : 15
EQUAL                : 50 52 54 63 70
FALSE                : 46
FLOAT                : 6 20
FNUMBER              : 33
FOR                  : 18
GREATERTHAN          : 56 65
ID                   : 5 6 7 8 19 20 21 22 23 24 25 26 27 28 39 42 43 43 47 52 53 54 55 56 57 58 59 73
IF                   : 12
INT                  : 5 21
INUMBER              : 32
LESSTHAN             : 57 66
OR                   : 49
PRINT                : 73
STR                  : 40
STRING               : 7 22
TRUE                 : 45
WHILE                : 17
^                    : 28 38
error                : 
{                    : 12 13 15 17 18
}                    : 12 13 15 17 18

Nonterminals, with rules where they appear

block                : 2 12 13 15 17 18 0
bool                 : 62
booleanexp           : 8 10 12 13 17 18 48 48 49 49 50 50 51 51
boolop               : 
comp                 : 71
concat               : 41
control              : 4
elif                 : 12 13
else                 : 12
epsilon              : 14 16
expr                 : 19
num                  : 29
numcomp              : 61
numericexp           : 5 6 9 24 25 26 27 28 30 30 31 54 55 56 57 58 59 71 71
operator             : 30
prodstatement        : 3 18 18
statement            : 1 2
strcomp              : 60
stringexp            : 7 11 42 44 44 52 53 69 69 70 70

Parsing method: LALR

state 0

    (0) S' -> . block
    (1) block -> . statement
    (2) block -> . statement block
    (3) statement -> . prodstatement ;
    (4) statement -> . control
    (73) statement -> . PRINT ( ID )
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID
    (12) control -> . IF ( booleanexp ) { block } elif else
    (17) control -> . WHILE ( booleanexp ) { block }
    (18) control -> . FOR ( prodstatement ; booleanexp ; prodstatement ) { block }

    PRINT           shift and go to state 5
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    block                          shift and go to state 1
    statement                      shift and go to state 2
    prodstatement                  shift and go to state 3
    control                        shift and go to state 4

state 1

    (0) S' -> block .



state 2

    (1) block -> statement .
    (2) block -> statement . block
    (1) block -> . statement
    (2) block -> . statement block
    (3) statement -> . prodstatement ;
    (4) statement -> . control
    (73) statement -> . PRINT ( ID )
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID
    (12) control -> . IF ( booleanexp ) { block } elif else
    (17) control -> . WHILE ( booleanexp ) { block }
    (18) control -> . FOR ( prodstatement ; booleanexp ; prodstatement ) { block }

    $end            reduce using rule 1 (block -> statement .)
    }               reduce using rule 1 (block -> statement .)
    PRINT           shift and go to state 5
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    statement                      shift and go to state 2
    block                          shift and go to state 14
    prodstatement                  shift and go to state 3
    control                        shift and go to state 4

state 3

    (3) statement -> prodstatement . ;

    ;               shift and go to state 15


state 4

    (4) statement -> control .

    PRINT           reduce using rule 4 (statement -> control .)
    INT             reduce using rule 4 (statement -> control .)
    FLOAT           reduce using rule 4 (statement -> control .)
    STRING          reduce using rule 4 (statement -> control .)
    BOOLEAN         reduce using rule 4 (statement -> control .)
    ID              reduce using rule 4 (statement -> control .)
    IF              reduce using rule 4 (statement -> control .)
    WHILE           reduce using rule 4 (statement -> control .)
    FOR             reduce using rule 4 (statement -> control .)
    $end            reduce using rule 4 (statement -> control .)
    }               reduce using rule 4 (statement -> control .)


state 5

    (73) statement -> PRINT . ( ID )

    (               shift and go to state 16


state 6

    (19) prodstatement -> ID . = expr

    =               shift and go to state 17


state 7

    (5) prodstatement -> INT . ID = numericexp
    (21) prodstatement -> INT . ID

    ID              shift and go to state 18


state 8

    (6) prodstatement -> FLOAT . ID = numericexp
    (20) prodstatement -> FLOAT . ID

    ID              shift and go to state 19


state 9

    (7) prodstatement -> STRING . ID = stringexp
    (22) prodstatement -> STRING . ID

    ID              shift and go to state 20


state 10

    (8) prodstatement -> BOOLEAN . ID = booleanexp
    (23) prodstatement -> BOOLEAN . ID

    ID              shift and go to state 21


state 11

    (12) control -> IF . ( booleanexp ) { block } elif else

    (               shift and go to state 22


state 12

    (17) control -> WHILE . ( booleanexp ) { block }

    (               shift and go to state 23


state 13

    (18) control -> FOR . ( prodstatement ; booleanexp ; prodstatement ) { block }

    (               shift and go to state 24


state 14

    (2) block -> statement block .

    $end            reduce using rule 2 (block -> statement block .)
    }               reduce using rule 2 (block -> statement block .)


state 15

    (3) statement -> prodstatement ; .

    PRINT           reduce using rule 3 (statement -> prodstatement ; .)
    INT             reduce using rule 3 (statement -> prodstatement ; .)
    FLOAT           reduce using rule 3 (statement -> prodstatement ; .)
    STRING          reduce using rule 3 (statement -> prodstatement ; .)
    BOOLEAN         reduce using rule 3 (statement -> prodstatement ; .)
    ID              reduce using rule 3 (statement -> prodstatement ; .)
    IF              reduce using rule 3 (statement -> prodstatement ; .)
    WHILE           reduce using rule 3 (statement -> prodstatement ; .)
    FOR             reduce using rule 3 (statement -> prodstatement ; .)
    $end            reduce using rule 3 (statement -> prodstatement ; .)
    }               reduce using rule 3 (statement -> prodstatement ; .)


state 16

    (73) statement -> PRINT ( . ID )

    ID              shift and go to state 25


state 17

    (19) prodstatement -> ID = . expr
    (9) expr -> . numericexp
    (10) expr -> . booleanexp
    (11) expr -> . stringexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (32) num -> . INUMBER
    (33) num -> . FNUMBER
    (39) concat -> . ID
    (40) concat -> . STR

    ID              shift and go to state 26
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35
    STR             shift and go to state 36

    expr                           shift and go to state 27
    numericexp                     shift and go to state 28
    booleanexp                     shift and go to state 29
    stringexp                      shift and go to state 30
    num                            shift and go to state 31
    concat                         shift and go to state 33

state 18

    (5) prodstatement -> INT ID . = numericexp
    (21) prodstatement -> INT ID .

    =               shift and go to state 37
    ;               reduce using rule 21 (prodstatement -> INT ID .)
    )               reduce using rule 21 (prodstatement -> INT ID .)


state 19

    (6) prodstatement -> FLOAT ID . = numericexp
    (20) prodstatement -> FLOAT ID .

    =               shift and go to state 38
    ;               reduce using rule 20 (prodstatement -> FLOAT ID .)
    )               reduce using rule 20 (prodstatement -> FLOAT ID .)


state 20

    (7) prodstatement -> STRING ID . = stringexp
    (22) prodstatement -> STRING ID .

    =               shift and go to state 39
    ;               reduce using rule 22 (prodstatement -> STRING ID .)
    )               reduce using rule 22 (prodstatement -> STRING ID .)


state 21

    (8) prodstatement -> BOOLEAN ID . = booleanexp
    (23) prodstatement -> BOOLEAN ID .

    =               shift and go to state 40
    ;               reduce using rule 23 (prodstatement -> BOOLEAN ID .)
    )               reduce using rule 23 (prodstatement -> BOOLEAN ID .)


state 22

    (12) control -> IF ( . booleanexp ) { block } elif else
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 41

state 23

    (17) control -> WHILE ( . booleanexp ) { block }
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 43

state 24

    (18) control -> FOR ( . prodstatement ; booleanexp ; prodstatement ) { block }
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6

    prodstatement                  shift and go to state 44

state 25

    (73) statement -> PRINT ( ID . )

    )               shift and go to state 45


state 26

    (24) numericexp -> ID . + numericexp
    (25) numericexp -> ID . - numericexp
    (26) numericexp -> ID . / numericexp
    (27) numericexp -> ID . * numericexp
    (28) numericexp -> ID . ^ numericexp
    (52) booleanexp -> ID . EQUAL stringexp
    (53) booleanexp -> ID . DIFFERENT stringexp
    (54) booleanexp -> ID . EQUAL numericexp
    (55) booleanexp -> ID . DIFFERENT numericexp
    (56) booleanexp -> ID . GREATERTHAN numericexp
    (57) booleanexp -> ID . LESSTHAN numericexp
    (58) booleanexp -> ID . < numericexp
    (59) booleanexp -> ID . > numericexp
    (42) stringexp -> ID . + stringexp
    (43) stringexp -> ID . + ID
    (39) concat -> ID .

  ! shift/reduce conflict for + resolved as shift
    +               shift and go to state 46
    -               shift and go to state 47
    /               shift and go to state 48
    *               shift and go to state 49
    ^               shift and go to state 50
    EQUAL           shift and go to state 51
    DIFFERENT       shift and go to state 52
    GREATERTHAN     shift and go to state 53
    LESSTHAN        shift and go to state 54
    <               shift and go to state 55
    >               shift and go to state 56
    ;               reduce using rule 39 (concat -> ID .)
    )               reduce using rule 39 (concat -> ID .)

  ! +               [ reduce using rule 39 (concat -> ID .) ]


state 27

    (19) prodstatement -> ID = expr .

    ;               reduce using rule 19 (prodstatement -> ID = expr .)
    )               reduce using rule 19 (prodstatement -> ID = expr .)


state 28

    (9) expr -> numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    ;               reduce using rule 9 (expr -> numericexp .)
    )               reduce using rule 9 (expr -> numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 29

    (10) expr -> booleanexp .
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

    ;               reduce using rule 10 (expr -> booleanexp .)
    )               reduce using rule 10 (expr -> booleanexp .)
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66


state 30

    (11) expr -> stringexp .
    (44) stringexp -> stringexp . + stringexp

    ;               reduce using rule 11 (expr -> stringexp .)
    )               reduce using rule 11 (expr -> stringexp .)
    +               shift and go to state 67


state 31

    (29) numericexp -> num .

    +               reduce using rule 29 (numericexp -> num .)
    -               reduce using rule 29 (numericexp -> num .)
    *               reduce using rule 29 (numericexp -> num .)
    /               reduce using rule 29 (numericexp -> num .)
    ^               reduce using rule 29 (numericexp -> num .)
    ;               reduce using rule 29 (numericexp -> num .)
    )               reduce using rule 29 (numericexp -> num .)
    AND             reduce using rule 29 (numericexp -> num .)
    OR              reduce using rule 29 (numericexp -> num .)
    EQUAL           reduce using rule 29 (numericexp -> num .)
    DIFFERENT       reduce using rule 29 (numericexp -> num .)


state 32

    (31) numericexp -> ( . numericexp )
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 68
    num                            shift and go to state 31

state 33

    (41) stringexp -> concat .

    +               reduce using rule 41 (stringexp -> concat .)
    ;               reduce using rule 41 (stringexp -> concat .)
    )               reduce using rule 41 (stringexp -> concat .)
    AND             reduce using rule 41 (stringexp -> concat .)
    OR              reduce using rule 41 (stringexp -> concat .)
    EQUAL           reduce using rule 41 (stringexp -> concat .)
    DIFFERENT       reduce using rule 41 (stringexp -> concat .)


state 34

    (32) num -> INUMBER .

    +               reduce using rule 32 (num -> INUMBER .)
    -               reduce using rule 32 (num -> INUMBER .)
    *               reduce using rule 32 (num -> INUMBER .)
    /               reduce using rule 32 (num -> INUMBER .)
    ^               reduce using rule 32 (num -> INUMBER .)
    ;               reduce using rule 32 (num -> INUMBER .)
    )               reduce using rule 32 (num -> INUMBER .)
    AND             reduce using rule 32 (num -> INUMBER .)
    OR              reduce using rule 32 (num -> INUMBER .)
    EQUAL           reduce using rule 32 (num -> INUMBER .)
    DIFFERENT       reduce using rule 32 (num -> INUMBER .)


state 35

    (33) num -> FNUMBER .

    +               reduce using rule 33 (num -> FNUMBER .)
    -               reduce using rule 33 (num -> FNUMBER .)
    *               reduce using rule 33 (num -> FNUMBER .)
    /               reduce using rule 33 (num -> FNUMBER .)
    ^               reduce using rule 33 (num -> FNUMBER .)
    ;               reduce using rule 33 (num -> FNUMBER .)
    )               reduce using rule 33 (num -> FNUMBER .)
    AND             reduce using rule 33 (num -> FNUMBER .)
    OR              reduce using rule 33 (num -> FNUMBER .)
    EQUAL           reduce using rule 33 (num -> FNUMBER .)
    DIFFERENT       reduce using rule 33 (num -> FNUMBER .)


state 36

    (40) concat -> STR .

    +               reduce using rule 40 (concat -> STR .)
    ;               reduce using rule 40 (concat -> STR .)
    )               reduce using rule 40 (concat -> STR .)
    AND             reduce using rule 40 (concat -> STR .)
    OR              reduce using rule 40 (concat -> STR .)
    EQUAL           reduce using rule 40 (concat -> STR .)
    DIFFERENT       reduce using rule 40 (concat -> STR .)


state 37

    (5) prodstatement -> INT ID = . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 70
    num                            shift and go to state 31

state 38

    (6) prodstatement -> FLOAT ID = . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 71
    num                            shift and go to state 31

state 39

    (7) prodstatement -> STRING ID = . stringexp
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (39) concat -> . ID
    (40) concat -> . STR

    ID              shift and go to state 72
    STR             shift and go to state 36

    stringexp                      shift and go to state 73
    concat                         shift and go to state 33

state 40

    (8) prodstatement -> BOOLEAN ID = . booleanexp
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 74

state 41

    (12) control -> IF ( booleanexp . ) { block } elif else
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

    )               shift and go to state 75
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66


state 42

    (52) booleanexp -> ID . EQUAL stringexp
    (53) booleanexp -> ID . DIFFERENT stringexp
    (54) booleanexp -> ID . EQUAL numericexp
    (55) booleanexp -> ID . DIFFERENT numericexp
    (56) booleanexp -> ID . GREATERTHAN numericexp
    (57) booleanexp -> ID . LESSTHAN numericexp
    (58) booleanexp -> ID . < numericexp
    (59) booleanexp -> ID . > numericexp

    EQUAL           shift and go to state 51
    DIFFERENT       shift and go to state 52
    GREATERTHAN     shift and go to state 53
    LESSTHAN        shift and go to state 54
    <               shift and go to state 55
    >               shift and go to state 56


state 43

    (17) control -> WHILE ( booleanexp . ) { block }
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

    )               shift and go to state 76
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66


state 44

    (18) control -> FOR ( prodstatement . ; booleanexp ; prodstatement ) { block }

    ;               shift and go to state 77


state 45

    (73) statement -> PRINT ( ID ) .

    PRINT           reduce using rule 73 (statement -> PRINT ( ID ) .)
    INT             reduce using rule 73 (statement -> PRINT ( ID ) .)
    FLOAT           reduce using rule 73 (statement -> PRINT ( ID ) .)
    STRING          reduce using rule 73 (statement -> PRINT ( ID ) .)
    BOOLEAN         reduce using rule 73 (statement -> PRINT ( ID ) .)
    ID              reduce using rule 73 (statement -> PRINT ( ID ) .)
    IF              reduce using rule 73 (statement -> PRINT ( ID ) .)
    WHILE           reduce using rule 73 (statement -> PRINT ( ID ) .)
    FOR             reduce using rule 73 (statement -> PRINT ( ID ) .)
    $end            reduce using rule 73 (statement -> PRINT ( ID ) .)
    }               reduce using rule 73 (statement -> PRINT ( ID ) .)


state 46

    (24) numericexp -> ID + . numericexp
    (42) stringexp -> ID + . stringexp
    (43) stringexp -> ID + . ID
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (32) num -> . INUMBER
    (33) num -> . FNUMBER
    (39) concat -> . ID
    (40) concat -> . STR

    ID              shift and go to state 78
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35
    STR             shift and go to state 36

    numericexp                     shift and go to state 79
    stringexp                      shift and go to state 80
    num                            shift and go to state 31
    concat                         shift and go to state 33

state 47

    (25) numericexp -> ID - . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 81
    num                            shift and go to state 31

state 48

    (26) numericexp -> ID / . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 82
    num                            shift and go to state 31

state 49

    (27) numericexp -> ID * . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 83
    num                            shift and go to state 31

state 50

    (28) numericexp -> ID ^ . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 84
    num                            shift and go to state 31

state 51

    (52) booleanexp -> ID EQUAL . stringexp
    (54) booleanexp -> ID EQUAL . numericexp
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (39) concat -> . ID
    (40) concat -> . STR
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 85
    (               shift and go to state 32
    STR             shift and go to state 36
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    stringexp                      shift and go to state 86
    numericexp                     shift and go to state 87
    concat                         shift and go to state 33
    num                            shift and go to state 31

state 52

    (53) booleanexp -> ID DIFFERENT . stringexp
    (55) booleanexp -> ID DIFFERENT . numericexp
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (39) concat -> . ID
    (40) concat -> . STR
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 85
    (               shift and go to state 32
    STR             shift and go to state 36
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    stringexp                      shift and go to state 88
    numericexp                     shift and go to state 89
    concat                         shift and go to state 33
    num                            shift and go to state 31

state 53

    (56) booleanexp -> ID GREATERTHAN . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 90
    num                            shift and go to state 31

state 54

    (57) booleanexp -> ID LESSTHAN . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 91
    num                            shift and go to state 31

state 55

    (58) booleanexp -> ID < . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 92
    num                            shift and go to state 31

state 56

    (59) booleanexp -> ID > . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 93
    num                            shift and go to state 31

state 57

    (30) numericexp -> numericexp operator . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 94
    num                            shift and go to state 31

state 58

    (34) operator -> + .

    ID              reduce using rule 34 (operator -> + .)
    (               reduce using rule 34 (operator -> + .)
    INUMBER         reduce using rule 34 (operator -> + .)
    FNUMBER         reduce using rule 34 (operator -> + .)


state 59

    (35) operator -> - .

    ID              reduce using rule 35 (operator -> - .)
    (               reduce using rule 35 (operator -> - .)
    INUMBER         reduce using rule 35 (operator -> - .)
    FNUMBER         reduce using rule 35 (operator -> - .)


state 60

    (36) operator -> * .

    ID              reduce using rule 36 (operator -> * .)
    (               reduce using rule 36 (operator -> * .)
    INUMBER         reduce using rule 36 (operator -> * .)
    FNUMBER         reduce using rule 36 (operator -> * .)


state 61

    (37) operator -> / .

    ID              reduce using rule 37 (operator -> / .)
    (               reduce using rule 37 (operator -> / .)
    INUMBER         reduce using rule 37 (operator -> / .)
    FNUMBER         reduce using rule 37 (operator -> / .)


state 62

    (38) operator -> ^ .

    ID              reduce using rule 38 (operator -> ^ .)
    (               reduce using rule 38 (operator -> ^ .)
    INUMBER         reduce using rule 38 (operator -> ^ .)
    FNUMBER         reduce using rule 38 (operator -> ^ .)


state 63

    (48) booleanexp -> booleanexp AND . booleanexp
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 95

state 64

    (49) booleanexp -> booleanexp OR . booleanexp
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 96

state 65

    (50) booleanexp -> booleanexp EQUAL . booleanexp
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 97

state 66

    (51) booleanexp -> booleanexp DIFFERENT . booleanexp
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 98

state 67

    (44) stringexp -> stringexp + . stringexp
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (39) concat -> . ID
    (40) concat -> . STR

    ID              shift and go to state 72
    STR             shift and go to state 36

    stringexp                      shift and go to state 99
    concat                         shift and go to state 33

state 68

    (31) numericexp -> ( numericexp . )
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    )               shift and go to state 100
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 69

    (24) numericexp -> ID . + numericexp
    (25) numericexp -> ID . - numericexp
    (26) numericexp -> ID . / numericexp
    (27) numericexp -> ID . * numericexp
    (28) numericexp -> ID . ^ numericexp

    +               shift and go to state 101
    -               shift and go to state 47
    /               shift and go to state 48
    *               shift and go to state 49
    ^               shift and go to state 50


state 70

    (5) prodstatement -> INT ID = numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    ;               reduce using rule 5 (prodstatement -> INT ID = numericexp .)
    )               reduce using rule 5 (prodstatement -> INT ID = numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 71

    (6) prodstatement -> FLOAT ID = numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    ;               reduce using rule 6 (prodstatement -> FLOAT ID = numericexp .)
    )               reduce using rule 6 (prodstatement -> FLOAT ID = numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 72

    (42) stringexp -> ID . + stringexp
    (43) stringexp -> ID . + ID
    (39) concat -> ID .

  ! shift/reduce conflict for + resolved as shift
    +               shift and go to state 102
    ;               reduce using rule 39 (concat -> ID .)
    )               reduce using rule 39 (concat -> ID .)
    AND             reduce using rule 39 (concat -> ID .)
    OR              reduce using rule 39 (concat -> ID .)
    EQUAL           reduce using rule 39 (concat -> ID .)
    DIFFERENT       reduce using rule 39 (concat -> ID .)

  ! +               [ reduce using rule 39 (concat -> ID .) ]


state 73

    (7) prodstatement -> STRING ID = stringexp .
    (44) stringexp -> stringexp . + stringexp

    ;               reduce using rule 7 (prodstatement -> STRING ID = stringexp .)
    )               reduce using rule 7 (prodstatement -> STRING ID = stringexp .)
    +               shift and go to state 67


state 74

    (8) prodstatement -> BOOLEAN ID = booleanexp .
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

    ;               reduce using rule 8 (prodstatement -> BOOLEAN ID = booleanexp .)
    )               reduce using rule 8 (prodstatement -> BOOLEAN ID = booleanexp .)
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66


state 75

    (12) control -> IF ( booleanexp ) . { block } elif else

    {               shift and go to state 103


state 76

    (17) control -> WHILE ( booleanexp ) . { block }

    {               shift and go to state 104


state 77

    (18) control -> FOR ( prodstatement ; . booleanexp ; prodstatement ) { block }
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 105

state 78

    (43) stringexp -> ID + ID .
    (24) numericexp -> ID . + numericexp
    (25) numericexp -> ID . - numericexp
    (26) numericexp -> ID . / numericexp
    (27) numericexp -> ID . * numericexp
    (28) numericexp -> ID . ^ numericexp
    (42) stringexp -> ID . + stringexp
    (43) stringexp -> ID . + ID
    (39) concat -> ID .

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! reduce/reduce conflict for ; resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 39 (concat -> ID .)
    +               shift and go to state 46
    -               shift and go to state 47
    /               shift and go to state 48
    *               shift and go to state 49
    ^               shift and go to state 50
    ;               reduce using rule 39 (concat -> ID .)
    )               reduce using rule 39 (concat -> ID .)

  ! +               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! ;               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! )               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! +               [ reduce using rule 39 (concat -> ID .) ]


state 79

    (24) numericexp -> ID + numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 24 (numericexp -> ID + numericexp .)
    )               reduce using rule 24 (numericexp -> ID + numericexp .)
    AND             reduce using rule 24 (numericexp -> ID + numericexp .)
    OR              reduce using rule 24 (numericexp -> ID + numericexp .)
    EQUAL           reduce using rule 24 (numericexp -> ID + numericexp .)
    DIFFERENT       reduce using rule 24 (numericexp -> ID + numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

  ! +               [ reduce using rule 24 (numericexp -> ID + numericexp .) ]
  ! -               [ reduce using rule 24 (numericexp -> ID + numericexp .) ]
  ! *               [ reduce using rule 24 (numericexp -> ID + numericexp .) ]
  ! /               [ reduce using rule 24 (numericexp -> ID + numericexp .) ]
  ! ^               [ reduce using rule 24 (numericexp -> ID + numericexp .) ]

    operator                       shift and go to state 57

state 80

    (42) stringexp -> ID + stringexp .
    (44) stringexp -> stringexp . + stringexp

  ! shift/reduce conflict for + resolved as shift
    ;               reduce using rule 42 (stringexp -> ID + stringexp .)
    )               reduce using rule 42 (stringexp -> ID + stringexp .)
    AND             reduce using rule 42 (stringexp -> ID + stringexp .)
    OR              reduce using rule 42 (stringexp -> ID + stringexp .)
    EQUAL           reduce using rule 42 (stringexp -> ID + stringexp .)
    DIFFERENT       reduce using rule 42 (stringexp -> ID + stringexp .)
    +               shift and go to state 67

  ! +               [ reduce using rule 42 (stringexp -> ID + stringexp .) ]


state 81

    (25) numericexp -> ID - numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 25 (numericexp -> ID - numericexp .)
    )               reduce using rule 25 (numericexp -> ID - numericexp .)
    AND             reduce using rule 25 (numericexp -> ID - numericexp .)
    OR              reduce using rule 25 (numericexp -> ID - numericexp .)
    EQUAL           reduce using rule 25 (numericexp -> ID - numericexp .)
    DIFFERENT       reduce using rule 25 (numericexp -> ID - numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

  ! +               [ reduce using rule 25 (numericexp -> ID - numericexp .) ]
  ! -               [ reduce using rule 25 (numericexp -> ID - numericexp .) ]
  ! *               [ reduce using rule 25 (numericexp -> ID - numericexp .) ]
  ! /               [ reduce using rule 25 (numericexp -> ID - numericexp .) ]
  ! ^               [ reduce using rule 25 (numericexp -> ID - numericexp .) ]

    operator                       shift and go to state 57

state 82

    (26) numericexp -> ID / numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 26 (numericexp -> ID / numericexp .)
    )               reduce using rule 26 (numericexp -> ID / numericexp .)
    AND             reduce using rule 26 (numericexp -> ID / numericexp .)
    OR              reduce using rule 26 (numericexp -> ID / numericexp .)
    EQUAL           reduce using rule 26 (numericexp -> ID / numericexp .)
    DIFFERENT       reduce using rule 26 (numericexp -> ID / numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

  ! +               [ reduce using rule 26 (numericexp -> ID / numericexp .) ]
  ! -               [ reduce using rule 26 (numericexp -> ID / numericexp .) ]
  ! *               [ reduce using rule 26 (numericexp -> ID / numericexp .) ]
  ! /               [ reduce using rule 26 (numericexp -> ID / numericexp .) ]
  ! ^               [ reduce using rule 26 (numericexp -> ID / numericexp .) ]

    operator                       shift and go to state 57

state 83

    (27) numericexp -> ID * numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 27 (numericexp -> ID * numericexp .)
    )               reduce using rule 27 (numericexp -> ID * numericexp .)
    AND             reduce using rule 27 (numericexp -> ID * numericexp .)
    OR              reduce using rule 27 (numericexp -> ID * numericexp .)
    EQUAL           reduce using rule 27 (numericexp -> ID * numericexp .)
    DIFFERENT       reduce using rule 27 (numericexp -> ID * numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

  ! +               [ reduce using rule 27 (numericexp -> ID * numericexp .) ]
  ! -               [ reduce using rule 27 (numericexp -> ID * numericexp .) ]
  ! *               [ reduce using rule 27 (numericexp -> ID * numericexp .) ]
  ! /               [ reduce using rule 27 (numericexp -> ID * numericexp .) ]
  ! ^               [ reduce using rule 27 (numericexp -> ID * numericexp .) ]

    operator                       shift and go to state 57

state 84

    (28) numericexp -> ID ^ numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 28 (numericexp -> ID ^ numericexp .)
    )               reduce using rule 28 (numericexp -> ID ^ numericexp .)
    AND             reduce using rule 28 (numericexp -> ID ^ numericexp .)
    OR              reduce using rule 28 (numericexp -> ID ^ numericexp .)
    EQUAL           reduce using rule 28 (numericexp -> ID ^ numericexp .)
    DIFFERENT       reduce using rule 28 (numericexp -> ID ^ numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

  ! +               [ reduce using rule 28 (numericexp -> ID ^ numericexp .) ]
  ! -               [ reduce using rule 28 (numericexp -> ID ^ numericexp .) ]
  ! *               [ reduce using rule 28 (numericexp -> ID ^ numericexp .) ]
  ! /               [ reduce using rule 28 (numericexp -> ID ^ numericexp .) ]
  ! ^               [ reduce using rule 28 (numericexp -> ID ^ numericexp .) ]

    operator                       shift and go to state 57

state 85

    (42) stringexp -> ID . + stringexp
    (43) stringexp -> ID . + ID
    (24) numericexp -> ID . + numericexp
    (25) numericexp -> ID . - numericexp
    (26) numericexp -> ID . / numericexp
    (27) numericexp -> ID . * numericexp
    (28) numericexp -> ID . ^ numericexp
    (39) concat -> ID .

  ! shift/reduce conflict for + resolved as shift
    +               shift and go to state 106
    -               shift and go to state 47
    /               shift and go to state 48
    *               shift and go to state 49
    ^               shift and go to state 50
    AND             reduce using rule 39 (concat -> ID .)
    OR              reduce using rule 39 (concat -> ID .)
    EQUAL           reduce using rule 39 (concat -> ID .)
    DIFFERENT       reduce using rule 39 (concat -> ID .)
    ;               reduce using rule 39 (concat -> ID .)
    )               reduce using rule 39 (concat -> ID .)

  ! +               [ reduce using rule 39 (concat -> ID .) ]


state 86

    (52) booleanexp -> ID EQUAL stringexp .
    (44) stringexp -> stringexp . + stringexp

    AND             reduce using rule 52 (booleanexp -> ID EQUAL stringexp .)
    OR              reduce using rule 52 (booleanexp -> ID EQUAL stringexp .)
    EQUAL           reduce using rule 52 (booleanexp -> ID EQUAL stringexp .)
    DIFFERENT       reduce using rule 52 (booleanexp -> ID EQUAL stringexp .)
    ;               reduce using rule 52 (booleanexp -> ID EQUAL stringexp .)
    )               reduce using rule 52 (booleanexp -> ID EQUAL stringexp .)
    +               shift and go to state 67


state 87

    (54) booleanexp -> ID EQUAL numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    AND             reduce using rule 54 (booleanexp -> ID EQUAL numericexp .)
    OR              reduce using rule 54 (booleanexp -> ID EQUAL numericexp .)
    EQUAL           reduce using rule 54 (booleanexp -> ID EQUAL numericexp .)
    DIFFERENT       reduce using rule 54 (booleanexp -> ID EQUAL numericexp .)
    ;               reduce using rule 54 (booleanexp -> ID EQUAL numericexp .)
    )               reduce using rule 54 (booleanexp -> ID EQUAL numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 88

    (53) booleanexp -> ID DIFFERENT stringexp .
    (44) stringexp -> stringexp . + stringexp

    AND             reduce using rule 53 (booleanexp -> ID DIFFERENT stringexp .)
    OR              reduce using rule 53 (booleanexp -> ID DIFFERENT stringexp .)
    EQUAL           reduce using rule 53 (booleanexp -> ID DIFFERENT stringexp .)
    DIFFERENT       reduce using rule 53 (booleanexp -> ID DIFFERENT stringexp .)
    ;               reduce using rule 53 (booleanexp -> ID DIFFERENT stringexp .)
    )               reduce using rule 53 (booleanexp -> ID DIFFERENT stringexp .)
    +               shift and go to state 67


state 89

    (55) booleanexp -> ID DIFFERENT numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    AND             reduce using rule 55 (booleanexp -> ID DIFFERENT numericexp .)
    OR              reduce using rule 55 (booleanexp -> ID DIFFERENT numericexp .)
    EQUAL           reduce using rule 55 (booleanexp -> ID DIFFERENT numericexp .)
    DIFFERENT       reduce using rule 55 (booleanexp -> ID DIFFERENT numericexp .)
    ;               reduce using rule 55 (booleanexp -> ID DIFFERENT numericexp .)
    )               reduce using rule 55 (booleanexp -> ID DIFFERENT numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 90

    (56) booleanexp -> ID GREATERTHAN numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    AND             reduce using rule 56 (booleanexp -> ID GREATERTHAN numericexp .)
    OR              reduce using rule 56 (booleanexp -> ID GREATERTHAN numericexp .)
    EQUAL           reduce using rule 56 (booleanexp -> ID GREATERTHAN numericexp .)
    DIFFERENT       reduce using rule 56 (booleanexp -> ID GREATERTHAN numericexp .)
    ;               reduce using rule 56 (booleanexp -> ID GREATERTHAN numericexp .)
    )               reduce using rule 56 (booleanexp -> ID GREATERTHAN numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 91

    (57) booleanexp -> ID LESSTHAN numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    AND             reduce using rule 57 (booleanexp -> ID LESSTHAN numericexp .)
    OR              reduce using rule 57 (booleanexp -> ID LESSTHAN numericexp .)
    EQUAL           reduce using rule 57 (booleanexp -> ID LESSTHAN numericexp .)
    DIFFERENT       reduce using rule 57 (booleanexp -> ID LESSTHAN numericexp .)
    ;               reduce using rule 57 (booleanexp -> ID LESSTHAN numericexp .)
    )               reduce using rule 57 (booleanexp -> ID LESSTHAN numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 92

    (58) booleanexp -> ID < numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    AND             reduce using rule 58 (booleanexp -> ID < numericexp .)
    OR              reduce using rule 58 (booleanexp -> ID < numericexp .)
    EQUAL           reduce using rule 58 (booleanexp -> ID < numericexp .)
    DIFFERENT       reduce using rule 58 (booleanexp -> ID < numericexp .)
    ;               reduce using rule 58 (booleanexp -> ID < numericexp .)
    )               reduce using rule 58 (booleanexp -> ID < numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 93

    (59) booleanexp -> ID > numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

    AND             reduce using rule 59 (booleanexp -> ID > numericexp .)
    OR              reduce using rule 59 (booleanexp -> ID > numericexp .)
    EQUAL           reduce using rule 59 (booleanexp -> ID > numericexp .)
    DIFFERENT       reduce using rule 59 (booleanexp -> ID > numericexp .)
    ;               reduce using rule 59 (booleanexp -> ID > numericexp .)
    )               reduce using rule 59 (booleanexp -> ID > numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

    operator                       shift and go to state 57

state 94

    (30) numericexp -> numericexp operator numericexp .
    (30) numericexp -> numericexp . operator numericexp
    (34) operator -> . +
    (35) operator -> . -
    (36) operator -> . *
    (37) operator -> . /
    (38) operator -> . ^

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for ^ resolved as shift
    ;               reduce using rule 30 (numericexp -> numericexp operator numericexp .)
    )               reduce using rule 30 (numericexp -> numericexp operator numericexp .)
    AND             reduce using rule 30 (numericexp -> numericexp operator numericexp .)
    OR              reduce using rule 30 (numericexp -> numericexp operator numericexp .)
    EQUAL           reduce using rule 30 (numericexp -> numericexp operator numericexp .)
    DIFFERENT       reduce using rule 30 (numericexp -> numericexp operator numericexp .)
    +               shift and go to state 58
    -               shift and go to state 59
    *               shift and go to state 60
    /               shift and go to state 61
    ^               shift and go to state 62

  ! +               [ reduce using rule 30 (numericexp -> numericexp operator numericexp .) ]
  ! -               [ reduce using rule 30 (numericexp -> numericexp operator numericexp .) ]
  ! *               [ reduce using rule 30 (numericexp -> numericexp operator numericexp .) ]
  ! /               [ reduce using rule 30 (numericexp -> numericexp operator numericexp .) ]
  ! ^               [ reduce using rule 30 (numericexp -> numericexp operator numericexp .) ]

    operator                       shift and go to state 57

state 95

    (48) booleanexp -> booleanexp AND booleanexp .
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    ;               reduce using rule 48 (booleanexp -> booleanexp AND booleanexp .)
    )               reduce using rule 48 (booleanexp -> booleanexp AND booleanexp .)
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66

  ! AND             [ reduce using rule 48 (booleanexp -> booleanexp AND booleanexp .) ]
  ! OR              [ reduce using rule 48 (booleanexp -> booleanexp AND booleanexp .) ]
  ! EQUAL           [ reduce using rule 48 (booleanexp -> booleanexp AND booleanexp .) ]
  ! DIFFERENT       [ reduce using rule 48 (booleanexp -> booleanexp AND booleanexp .) ]


state 96

    (49) booleanexp -> booleanexp OR booleanexp .
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    ;               reduce using rule 49 (booleanexp -> booleanexp OR booleanexp .)
    )               reduce using rule 49 (booleanexp -> booleanexp OR booleanexp .)
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66

  ! AND             [ reduce using rule 49 (booleanexp -> booleanexp OR booleanexp .) ]
  ! OR              [ reduce using rule 49 (booleanexp -> booleanexp OR booleanexp .) ]
  ! EQUAL           [ reduce using rule 49 (booleanexp -> booleanexp OR booleanexp .) ]
  ! DIFFERENT       [ reduce using rule 49 (booleanexp -> booleanexp OR booleanexp .) ]


state 97

    (50) booleanexp -> booleanexp EQUAL booleanexp .
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    ;               reduce using rule 50 (booleanexp -> booleanexp EQUAL booleanexp .)
    )               reduce using rule 50 (booleanexp -> booleanexp EQUAL booleanexp .)
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66

  ! AND             [ reduce using rule 50 (booleanexp -> booleanexp EQUAL booleanexp .) ]
  ! OR              [ reduce using rule 50 (booleanexp -> booleanexp EQUAL booleanexp .) ]
  ! EQUAL           [ reduce using rule 50 (booleanexp -> booleanexp EQUAL booleanexp .) ]
  ! DIFFERENT       [ reduce using rule 50 (booleanexp -> booleanexp EQUAL booleanexp .) ]


state 98

    (51) booleanexp -> booleanexp DIFFERENT booleanexp .
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for EQUAL resolved as shift
  ! shift/reduce conflict for DIFFERENT resolved as shift
    ;               reduce using rule 51 (booleanexp -> booleanexp DIFFERENT booleanexp .)
    )               reduce using rule 51 (booleanexp -> booleanexp DIFFERENT booleanexp .)
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66

  ! AND             [ reduce using rule 51 (booleanexp -> booleanexp DIFFERENT booleanexp .) ]
  ! OR              [ reduce using rule 51 (booleanexp -> booleanexp DIFFERENT booleanexp .) ]
  ! EQUAL           [ reduce using rule 51 (booleanexp -> booleanexp DIFFERENT booleanexp .) ]
  ! DIFFERENT       [ reduce using rule 51 (booleanexp -> booleanexp DIFFERENT booleanexp .) ]


state 99

    (44) stringexp -> stringexp + stringexp .
    (44) stringexp -> stringexp . + stringexp

  ! shift/reduce conflict for + resolved as shift
    ;               reduce using rule 44 (stringexp -> stringexp + stringexp .)
    )               reduce using rule 44 (stringexp -> stringexp + stringexp .)
    AND             reduce using rule 44 (stringexp -> stringexp + stringexp .)
    OR              reduce using rule 44 (stringexp -> stringexp + stringexp .)
    EQUAL           reduce using rule 44 (stringexp -> stringexp + stringexp .)
    DIFFERENT       reduce using rule 44 (stringexp -> stringexp + stringexp .)
    +               shift and go to state 67

  ! +               [ reduce using rule 44 (stringexp -> stringexp + stringexp .) ]


state 100

    (31) numericexp -> ( numericexp ) .

    +               reduce using rule 31 (numericexp -> ( numericexp ) .)
    -               reduce using rule 31 (numericexp -> ( numericexp ) .)
    *               reduce using rule 31 (numericexp -> ( numericexp ) .)
    /               reduce using rule 31 (numericexp -> ( numericexp ) .)
    ^               reduce using rule 31 (numericexp -> ( numericexp ) .)
    ;               reduce using rule 31 (numericexp -> ( numericexp ) .)
    )               reduce using rule 31 (numericexp -> ( numericexp ) .)
    AND             reduce using rule 31 (numericexp -> ( numericexp ) .)
    OR              reduce using rule 31 (numericexp -> ( numericexp ) .)
    EQUAL           reduce using rule 31 (numericexp -> ( numericexp ) .)
    DIFFERENT       reduce using rule 31 (numericexp -> ( numericexp ) .)


state 101

    (24) numericexp -> ID + . numericexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 69
    (               shift and go to state 32
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    numericexp                     shift and go to state 79
    num                            shift and go to state 31

state 102

    (42) stringexp -> ID + . stringexp
    (43) stringexp -> ID + . ID
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (39) concat -> . ID
    (40) concat -> . STR

    ID              shift and go to state 107
    STR             shift and go to state 36

    stringexp                      shift and go to state 80
    concat                         shift and go to state 33

state 103

    (12) control -> IF ( booleanexp ) { . block } elif else
    (1) block -> . statement
    (2) block -> . statement block
    (3) statement -> . prodstatement ;
    (4) statement -> . control
    (73) statement -> . PRINT ( ID )
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID
    (12) control -> . IF ( booleanexp ) { block } elif else
    (17) control -> . WHILE ( booleanexp ) { block }
    (18) control -> . FOR ( prodstatement ; booleanexp ; prodstatement ) { block }

    PRINT           shift and go to state 5
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    block                          shift and go to state 108
    statement                      shift and go to state 2
    prodstatement                  shift and go to state 3
    control                        shift and go to state 4

state 104

    (17) control -> WHILE ( booleanexp ) { . block }
    (1) block -> . statement
    (2) block -> . statement block
    (3) statement -> . prodstatement ;
    (4) statement -> . control
    (73) statement -> . PRINT ( ID )
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID
    (12) control -> . IF ( booleanexp ) { block } elif else
    (17) control -> . WHILE ( booleanexp ) { block }
    (18) control -> . FOR ( prodstatement ; booleanexp ; prodstatement ) { block }

    PRINT           shift and go to state 5
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    block                          shift and go to state 109
    statement                      shift and go to state 2
    prodstatement                  shift and go to state 3
    control                        shift and go to state 4

state 105

    (18) control -> FOR ( prodstatement ; booleanexp . ; prodstatement ) { block }
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

    ;               shift and go to state 110
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66


state 106

    (42) stringexp -> ID + . stringexp
    (43) stringexp -> ID + . ID
    (24) numericexp -> ID + . numericexp
    (41) stringexp -> . concat
    (42) stringexp -> . ID + stringexp
    (43) stringexp -> . ID + ID
    (44) stringexp -> . stringexp + stringexp
    (24) numericexp -> . ID + numericexp
    (25) numericexp -> . ID - numericexp
    (26) numericexp -> . ID / numericexp
    (27) numericexp -> . ID * numericexp
    (28) numericexp -> . ID ^ numericexp
    (29) numericexp -> . num
    (30) numericexp -> . numericexp operator numericexp
    (31) numericexp -> . ( numericexp )
    (39) concat -> . ID
    (40) concat -> . STR
    (32) num -> . INUMBER
    (33) num -> . FNUMBER

    ID              shift and go to state 111
    (               shift and go to state 32
    STR             shift and go to state 36
    INUMBER         shift and go to state 34
    FNUMBER         shift and go to state 35

    stringexp                      shift and go to state 80
    numericexp                     shift and go to state 79
    concat                         shift and go to state 33
    num                            shift and go to state 31

state 107

    (43) stringexp -> ID + ID .
    (42) stringexp -> ID . + stringexp
    (43) stringexp -> ID . + ID
    (39) concat -> ID .

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! reduce/reduce conflict for ; resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for EQUAL resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 39 (concat -> ID .)
    +               shift and go to state 102
    ;               reduce using rule 39 (concat -> ID .)
    )               reduce using rule 39 (concat -> ID .)
    AND             reduce using rule 39 (concat -> ID .)
    OR              reduce using rule 39 (concat -> ID .)
    EQUAL           reduce using rule 39 (concat -> ID .)
    DIFFERENT       reduce using rule 39 (concat -> ID .)

  ! +               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! ;               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! )               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! AND             [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! OR              [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! EQUAL           [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! DIFFERENT       [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! +               [ reduce using rule 39 (concat -> ID .) ]


state 108

    (12) control -> IF ( booleanexp ) { block . } elif else

    }               shift and go to state 112


state 109

    (17) control -> WHILE ( booleanexp ) { block . }

    }               shift and go to state 113


state 110

    (18) control -> FOR ( prodstatement ; booleanexp ; . prodstatement ) { block }
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID

    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6

    prodstatement                  shift and go to state 114

state 111

    (43) stringexp -> ID + ID .
    (42) stringexp -> ID . + stringexp
    (43) stringexp -> ID . + ID
    (24) numericexp -> ID . + numericexp
    (25) numericexp -> ID . - numericexp
    (26) numericexp -> ID . / numericexp
    (27) numericexp -> ID . * numericexp
    (28) numericexp -> ID . ^ numericexp
    (39) concat -> ID .

  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! reduce/reduce conflict for AND resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for EQUAL resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for DIFFERENT resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for ; resolved using rule 39 (concat -> ID .)
  ! reduce/reduce conflict for ) resolved using rule 39 (concat -> ID .)
    +               shift and go to state 106
    -               shift and go to state 47
    /               shift and go to state 48
    *               shift and go to state 49
    ^               shift and go to state 50
    AND             reduce using rule 39 (concat -> ID .)
    OR              reduce using rule 39 (concat -> ID .)
    EQUAL           reduce using rule 39 (concat -> ID .)
    DIFFERENT       reduce using rule 39 (concat -> ID .)
    ;               reduce using rule 39 (concat -> ID .)
    )               reduce using rule 39 (concat -> ID .)

  ! +               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! AND             [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! OR              [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! EQUAL           [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! DIFFERENT       [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! ;               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! )               [ reduce using rule 43 (stringexp -> ID + ID .) ]
  ! +               [ reduce using rule 39 (concat -> ID .) ]


state 112

    (12) control -> IF ( booleanexp ) { block } . elif else
    (13) elif -> . ELIF ( booleanexp ) { block } elif
    (14) elif -> . epsilon
    (72) epsilon -> .

    ELIF            shift and go to state 116
    ELSE            reduce using rule 72 (epsilon -> .)
    PRINT           reduce using rule 72 (epsilon -> .)
    INT             reduce using rule 72 (epsilon -> .)
    FLOAT           reduce using rule 72 (epsilon -> .)
    STRING          reduce using rule 72 (epsilon -> .)
    BOOLEAN         reduce using rule 72 (epsilon -> .)
    ID              reduce using rule 72 (epsilon -> .)
    IF              reduce using rule 72 (epsilon -> .)
    WHILE           reduce using rule 72 (epsilon -> .)
    FOR             reduce using rule 72 (epsilon -> .)
    $end            reduce using rule 72 (epsilon -> .)
    }               reduce using rule 72 (epsilon -> .)

    elif                           shift and go to state 115
    epsilon                        shift and go to state 117

state 113

    (17) control -> WHILE ( booleanexp ) { block } .

    PRINT           reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    INT             reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    FLOAT           reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    STRING          reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    BOOLEAN         reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    ID              reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    IF              reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    WHILE           reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    FOR             reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    $end            reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)
    }               reduce using rule 17 (control -> WHILE ( booleanexp ) { block } .)


state 114

    (18) control -> FOR ( prodstatement ; booleanexp ; prodstatement . ) { block }

    )               shift and go to state 118


state 115

    (12) control -> IF ( booleanexp ) { block } elif . else
    (15) else -> . ELSE { block }
    (16) else -> . epsilon
    (72) epsilon -> .

    ELSE            shift and go to state 120
    PRINT           reduce using rule 72 (epsilon -> .)
    INT             reduce using rule 72 (epsilon -> .)
    FLOAT           reduce using rule 72 (epsilon -> .)
    STRING          reduce using rule 72 (epsilon -> .)
    BOOLEAN         reduce using rule 72 (epsilon -> .)
    ID              reduce using rule 72 (epsilon -> .)
    IF              reduce using rule 72 (epsilon -> .)
    WHILE           reduce using rule 72 (epsilon -> .)
    FOR             reduce using rule 72 (epsilon -> .)
    $end            reduce using rule 72 (epsilon -> .)
    }               reduce using rule 72 (epsilon -> .)

    else                           shift and go to state 119
    epsilon                        shift and go to state 121

state 116

    (13) elif -> ELIF . ( booleanexp ) { block } elif

    (               shift and go to state 122


state 117

    (14) elif -> epsilon .

    ELSE            reduce using rule 14 (elif -> epsilon .)
    PRINT           reduce using rule 14 (elif -> epsilon .)
    INT             reduce using rule 14 (elif -> epsilon .)
    FLOAT           reduce using rule 14 (elif -> epsilon .)
    STRING          reduce using rule 14 (elif -> epsilon .)
    BOOLEAN         reduce using rule 14 (elif -> epsilon .)
    ID              reduce using rule 14 (elif -> epsilon .)
    IF              reduce using rule 14 (elif -> epsilon .)
    WHILE           reduce using rule 14 (elif -> epsilon .)
    FOR             reduce using rule 14 (elif -> epsilon .)
    $end            reduce using rule 14 (elif -> epsilon .)
    }               reduce using rule 14 (elif -> epsilon .)


state 118

    (18) control -> FOR ( prodstatement ; booleanexp ; prodstatement ) . { block }

    {               shift and go to state 123


state 119

    (12) control -> IF ( booleanexp ) { block } elif else .

    PRINT           reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    INT             reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    FLOAT           reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    STRING          reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    BOOLEAN         reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    ID              reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    IF              reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    WHILE           reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    FOR             reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    $end            reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)
    }               reduce using rule 12 (control -> IF ( booleanexp ) { block } elif else .)


state 120

    (15) else -> ELSE . { block }

    {               shift and go to state 124


state 121

    (16) else -> epsilon .

    PRINT           reduce using rule 16 (else -> epsilon .)
    INT             reduce using rule 16 (else -> epsilon .)
    FLOAT           reduce using rule 16 (else -> epsilon .)
    STRING          reduce using rule 16 (else -> epsilon .)
    BOOLEAN         reduce using rule 16 (else -> epsilon .)
    ID              reduce using rule 16 (else -> epsilon .)
    IF              reduce using rule 16 (else -> epsilon .)
    WHILE           reduce using rule 16 (else -> epsilon .)
    FOR             reduce using rule 16 (else -> epsilon .)
    $end            reduce using rule 16 (else -> epsilon .)
    }               reduce using rule 16 (else -> epsilon .)


state 122

    (13) elif -> ELIF ( . booleanexp ) { block } elif
    (48) booleanexp -> . booleanexp AND booleanexp
    (49) booleanexp -> . booleanexp OR booleanexp
    (50) booleanexp -> . booleanexp EQUAL booleanexp
    (51) booleanexp -> . booleanexp DIFFERENT booleanexp
    (52) booleanexp -> . ID EQUAL stringexp
    (53) booleanexp -> . ID DIFFERENT stringexp
    (54) booleanexp -> . ID EQUAL numericexp
    (55) booleanexp -> . ID DIFFERENT numericexp
    (56) booleanexp -> . ID GREATERTHAN numericexp
    (57) booleanexp -> . ID LESSTHAN numericexp
    (58) booleanexp -> . ID < numericexp
    (59) booleanexp -> . ID > numericexp

    ID              shift and go to state 42

    booleanexp                     shift and go to state 125

state 123

    (18) control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { . block }
    (1) block -> . statement
    (2) block -> . statement block
    (3) statement -> . prodstatement ;
    (4) statement -> . control
    (73) statement -> . PRINT ( ID )
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID
    (12) control -> . IF ( booleanexp ) { block } elif else
    (17) control -> . WHILE ( booleanexp ) { block }
    (18) control -> . FOR ( prodstatement ; booleanexp ; prodstatement ) { block }

    PRINT           shift and go to state 5
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    prodstatement                  shift and go to state 3
    block                          shift and go to state 126
    statement                      shift and go to state 2
    control                        shift and go to state 4

state 124

    (15) else -> ELSE { . block }
    (1) block -> . statement
    (2) block -> . statement block
    (3) statement -> . prodstatement ;
    (4) statement -> . control
    (73) statement -> . PRINT ( ID )
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID
    (12) control -> . IF ( booleanexp ) { block } elif else
    (17) control -> . WHILE ( booleanexp ) { block }
    (18) control -> . FOR ( prodstatement ; booleanexp ; prodstatement ) { block }

    PRINT           shift and go to state 5
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    block                          shift and go to state 127
    statement                      shift and go to state 2
    prodstatement                  shift and go to state 3
    control                        shift and go to state 4

state 125

    (13) elif -> ELIF ( booleanexp . ) { block } elif
    (48) booleanexp -> booleanexp . AND booleanexp
    (49) booleanexp -> booleanexp . OR booleanexp
    (50) booleanexp -> booleanexp . EQUAL booleanexp
    (51) booleanexp -> booleanexp . DIFFERENT booleanexp

    )               shift and go to state 128
    AND             shift and go to state 63
    OR              shift and go to state 64
    EQUAL           shift and go to state 65
    DIFFERENT       shift and go to state 66


state 126

    (18) control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block . }

    }               shift and go to state 129


state 127

    (15) else -> ELSE { block . }

    }               shift and go to state 130


state 128

    (13) elif -> ELIF ( booleanexp ) . { block } elif

    {               shift and go to state 131


state 129

    (18) control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .

    PRINT           reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    INT             reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    FLOAT           reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    STRING          reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    BOOLEAN         reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    ID              reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    IF              reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    WHILE           reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    FOR             reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    $end            reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)
    }               reduce using rule 18 (control -> FOR ( prodstatement ; booleanexp ; prodstatement ) { block } .)


state 130

    (15) else -> ELSE { block } .

    PRINT           reduce using rule 15 (else -> ELSE { block } .)
    INT             reduce using rule 15 (else -> ELSE { block } .)
    FLOAT           reduce using rule 15 (else -> ELSE { block } .)
    STRING          reduce using rule 15 (else -> ELSE { block } .)
    BOOLEAN         reduce using rule 15 (else -> ELSE { block } .)
    ID              reduce using rule 15 (else -> ELSE { block } .)
    IF              reduce using rule 15 (else -> ELSE { block } .)
    WHILE           reduce using rule 15 (else -> ELSE { block } .)
    FOR             reduce using rule 15 (else -> ELSE { block } .)
    $end            reduce using rule 15 (else -> ELSE { block } .)
    }               reduce using rule 15 (else -> ELSE { block } .)


state 131

    (13) elif -> ELIF ( booleanexp ) { . block } elif
    (1) block -> . statement
    (2) block -> . statement block
    (3) statement -> . prodstatement ;
    (4) statement -> . control
    (73) statement -> . PRINT ( ID )
    (5) prodstatement -> . INT ID = numericexp
    (6) prodstatement -> . FLOAT ID = numericexp
    (7) prodstatement -> . STRING ID = stringexp
    (8) prodstatement -> . BOOLEAN ID = booleanexp
    (19) prodstatement -> . ID = expr
    (20) prodstatement -> . FLOAT ID
    (21) prodstatement -> . INT ID
    (22) prodstatement -> . STRING ID
    (23) prodstatement -> . BOOLEAN ID
    (12) control -> . IF ( booleanexp ) { block } elif else
    (17) control -> . WHILE ( booleanexp ) { block }
    (18) control -> . FOR ( prodstatement ; booleanexp ; prodstatement ) { block }

    PRINT           shift and go to state 5
    INT             shift and go to state 7
    FLOAT           shift and go to state 8
    STRING          shift and go to state 9
    BOOLEAN         shift and go to state 10
    ID              shift and go to state 6
    IF              shift and go to state 11
    WHILE           shift and go to state 12
    FOR             shift and go to state 13

    block                          shift and go to state 132
    statement                      shift and go to state 2
    prodstatement                  shift and go to state 3
    control                        shift and go to state 4

state 132

    (13) elif -> ELIF ( booleanexp ) { block . } elif

    }               shift and go to state 133


state 133

    (13) elif -> ELIF ( booleanexp ) { block } . elif
    (13) elif -> . ELIF ( booleanexp ) { block } elif
    (14) elif -> . epsilon
    (72) epsilon -> .

    ELIF            shift and go to state 116
    ELSE            reduce using rule 72 (epsilon -> .)
    PRINT           reduce using rule 72 (epsilon -> .)
    INT             reduce using rule 72 (epsilon -> .)
    FLOAT           reduce using rule 72 (epsilon -> .)
    STRING          reduce using rule 72 (epsilon -> .)
    BOOLEAN         reduce using rule 72 (epsilon -> .)
    ID              reduce using rule 72 (epsilon -> .)
    IF              reduce using rule 72 (epsilon -> .)
    WHILE           reduce using rule 72 (epsilon -> .)
    FOR             reduce using rule 72 (epsilon -> .)
    $end            reduce using rule 72 (epsilon -> .)
    }               reduce using rule 72 (epsilon -> .)

    elif                           shift and go to state 134
    epsilon                        shift and go to state 117

state 134

    (13) elif -> ELIF ( booleanexp ) { block } elif .

    ELSE            reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    PRINT           reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    INT             reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    FLOAT           reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    STRING          reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    BOOLEAN         reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    ID              reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    IF              reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    WHILE           reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    FOR             reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    $end            reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)
    }               reduce using rule 13 (elif -> ELIF ( booleanexp ) { block } elif .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for + in state 26 resolved as shift
WARNING: shift/reduce conflict for + in state 72 resolved as shift
WARNING: shift/reduce conflict for + in state 78 resolved as shift
WARNING: shift/reduce conflict for + in state 78 resolved as shift
WARNING: shift/reduce conflict for + in state 79 resolved as shift
WARNING: shift/reduce conflict for - in state 79 resolved as shift
WARNING: shift/reduce conflict for * in state 79 resolved as shift
WARNING: shift/reduce conflict for / in state 79 resolved as shift
WARNING: shift/reduce conflict for ^ in state 79 resolved as shift
WARNING: shift/reduce conflict for + in state 80 resolved as shift
WARNING: shift/reduce conflict for + in state 81 resolved as shift
WARNING: shift/reduce conflict for - in state 81 resolved as shift
WARNING: shift/reduce conflict for * in state 81 resolved as shift
WARNING: shift/reduce conflict for / in state 81 resolved as shift
WARNING: shift/reduce conflict for ^ in state 81 resolved as shift
WARNING: shift/reduce conflict for + in state 82 resolved as shift
WARNING: shift/reduce conflict for - in state 82 resolved as shift
WARNING: shift/reduce conflict for * in state 82 resolved as shift
WARNING: shift/reduce conflict for / in state 82 resolved as shift
WARNING: shift/reduce conflict for ^ in state 82 resolved as shift
WARNING: shift/reduce conflict for + in state 83 resolved as shift
WARNING: shift/reduce conflict for - in state 83 resolved as shift
WARNING: shift/reduce conflict for * in state 83 resolved as shift
WARNING: shift/reduce conflict for / in state 83 resolved as shift
WARNING: shift/reduce conflict for ^ in state 83 resolved as shift
WARNING: shift/reduce conflict for + in state 84 resolved as shift
WARNING: shift/reduce conflict for - in state 84 resolved as shift
WARNING: shift/reduce conflict for * in state 84 resolved as shift
WARNING: shift/reduce conflict for / in state 84 resolved as shift
WARNING: shift/reduce conflict for ^ in state 84 resolved as shift
WARNING: shift/reduce conflict for + in state 85 resolved as shift
WARNING: shift/reduce conflict for + in state 94 resolved as shift
WARNING: shift/reduce conflict for - in state 94 resolved as shift
WARNING: shift/reduce conflict for * in state 94 resolved as shift
WARNING: shift/reduce conflict for / in state 94 resolved as shift
WARNING: shift/reduce conflict for ^ in state 94 resolved as shift
WARNING: shift/reduce conflict for AND in state 95 resolved as shift
WARNING: shift/reduce conflict for OR in state 95 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 95 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 95 resolved as shift
WARNING: shift/reduce conflict for AND in state 96 resolved as shift
WARNING: shift/reduce conflict for OR in state 96 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 96 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 96 resolved as shift
WARNING: shift/reduce conflict for AND in state 97 resolved as shift
WARNING: shift/reduce conflict for OR in state 97 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 97 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 97 resolved as shift
WARNING: shift/reduce conflict for AND in state 98 resolved as shift
WARNING: shift/reduce conflict for OR in state 98 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 98 resolved as shift
WARNING: shift/reduce conflict for DIFFERENT in state 98 resolved as shift
WARNING: shift/reduce conflict for + in state 99 resolved as shift
WARNING: shift/reduce conflict for + in state 107 resolved as shift
WARNING: shift/reduce conflict for + in state 107 resolved as shift
WARNING: shift/reduce conflict for + in state 111 resolved as shift
WARNING: shift/reduce conflict for + in state 111 resolved as shift
WARNING: reduce/reduce conflict in state 78 resolved using rule (concat -> ID)
WARNING: rejected rule (stringexp -> ID + ID) in state 78
WARNING: reduce/reduce conflict in state 107 resolved using rule (concat -> ID)
WARNING: rejected rule (stringexp -> ID + ID) in state 107
WARNING: reduce/reduce conflict in state 111 resolved using rule (concat -> ID)
WARNING: rejected rule (stringexp -> ID + ID) in state 111
WARNING: Rule (stringexp -> ID + ID) is never reduced
